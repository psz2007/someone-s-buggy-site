当直接给出一个 `"abcd"` 时，表示一个字符串常量，这个常量已经有了自己的内存空间。

因此如果 `char a[20]; a="abcd"` 会错，因为 `a` 是一个不可修改的指针地址。

可以初始化 `char a[20]="abcd;`

而如果直接定义的是指针 `char *p;p="abcd"` 则合法，因为我们移动了指针。

---

`define` 替换的内容，是直接替换，不要加括号。

---

`#include"stdio.h"` 先在源文件文件夹中找，找不到去“包含路径”，再找不到就去找 `<stdio.h>` 库文件。

头文件会把头文件里面的内容放进来编译，进行的是文本替换，因此定义头文件中有的函数会报错。

多个程序一起编译，里面定义的函数会放在一起，因此有重复地定义会爆。

`static` 定义就是说明，只在这个代码中使用，因此可以重复。

别的源代码写的函数，我这里要用，要在前面声明。

`main` 函数只能有一个，不能有 `static int main`。

---

函数内定义的局部变量函数结束后清除。

---

`int a[5];int *p;p=a` 是合法，指针指向 `a[0]`。

`int *p[5]` ，方括号的优先级比 `*` 高，因此这是指针数组。

`int (*p)[5]` ，强制先是指针，因此是指向数组的指针，写成类型就是 `int (*)[5]` 。

`int a[5][5]`，`a` 的类型就是 `(*)[5]`，所以 `int **p=a` 不合法。

`a` 可以强转成一维，`int *p=(int *)a`。

定义 `void f(int a[])` 的时候，这里的 `a[]` 和 `*a` 等价，完全当作指针使用。

`typedef int (*gg)[10];` 就是把 `gg` 变成了指向数组的指针。

`typedef` 实际上就是定义一个类型，用变量名来代替原来的类型。

---

`FILE *fp=fopen("文件名","模式");`

`fclose(fp);`

| 模式 | 含义 | 文件不存在时 | 文件存在时 | 读写权限 |
| :--- | :--- | :--- | :--- | :--- |
| **"r"** | **只读** (Read) | **报错** (返回 NULL) | 打开文件，指针指开头 | 仅读取 |
| **"w"** | **只写** (Write) | **新建**文件 | **清空**原内容 (覆盖) | 仅写入 |
| **"a"** | **追加** (Append) | **新建**文件 | 保留原内容，指针指**末尾** | 仅写入 |
| **"r+"**| **读写** (Update) | **报错** (返回 NULL) | 打开文件，指针指开头 | 可读可写 |
| **"w+"**| **读写** (Update) | **新建**文件 | **清空**原内容 | 可读可写 |
| **"a+"**| **读写追加** | **新建**文件 | 保留原内容，初始指末尾 | 可读可写 |

打开失败返回 0，关闭成功返回 0,失败返回 -1 。

fgets 读到文件末尾返回 -1 。

`fgets(st,n,fp)`，因此要调用 fp 的，读不出来了就是 -1 。

fopen 打开文件地址格式：`c:\\user\\text.txt`

---

`&a-&b` 算得是内存差除以 sizeof 类型，因此 `&a[2]-&a[1]` 一定是 $1$ 。

而 `sizeof(a)` 直接就是 a 里面元素总共有多少个字节。

`malloc` 分配的内存，只能手动 free 释放，或者程序结束后释放。

`a=(a 的类型)malloc(n*sizeof(类型))`

`malloc` 失败返回 $0$ 。

### 📋 C 语言运算符优先级总表

| 优先级 | 运算符 | 描述 | 结合方向 |
| :---: | :--- | :--- | :---: |
| **1** | `()` `[]` `->` `.` | 圆括号、数组下标、结构体指针成员、结构体成员 | 左 ➔ 右 |
| | `++` `--` | **后缀**自增/自减 (如 `a++`) | 左 ➔ 右 |
| **2** | `!` `~` | 逻辑非、按位取反 | **右 ⬅ 左** |
| | `++` `--` | **前缀**自增/自减 (如 `++a`) | **右 ⬅ 左** |
| | `+` `-` | 正号、负号 (一元运算符) | **右 ⬅ 左** |
| | `*` `&` | **解引用**(取值)、**取地址** | **右 ⬅ 左** |
| | `(type)` `sizeof` | 强制类型转换、计算大小 | **右 ⬅ 左** |
| **3** | `*` `/` `%` | 乘、除、取模 | 左 ➔ 右 |
| **4** | `+` `-` | 加、减 | 左 ➔ 右 |
| **5** | `<<` `>>` | 左移、右移 | 左 ➔ 右 |
| **6** | `<` `<=` `>` `>=` | 关系运算符 (小于、大于等) | 左 ➔ 右 |
| **7** | `==` `!=` | 等于、不等于 | 左 ➔ 右 |
| **8** | `&` | 按位与 | 左 ➔ 右 |
| **9** | `^` | 按位异或 | 左 ➔ 右 |
| **10** |   | 按位或 | 左 ➔ 右 |
| **11** | `&&` | 逻辑与 | 左 ➔ 右 |
| **12** |  | 逻辑或 | 左 ➔ 右 |
| **13** | `?:` | 三目运算符 | **右 ⬅ 左** |
| **14** | `=` `+=` `-=` `*=` `/=` 等 | 赋值及复合赋值 | **右 ⬅ 左** |
| **15** | `,` | 逗号运算符 | 左 ➔ 右 |

---

转义字符：

`'\007'` 指八进制转义，后面代表的数字直接是八进制。

`'\xe'` 带 `x` 的是十六进制转义。

没有十进制转义，因为 `127` 直接就可以表示十进制的字符。

直接数字的转义， 0x 开头十六进制，0开头八进制。

```
int a = 1, b = 2, c = 3, d = 4, m = 1, n = 2, v; 
v = (m = a > b) && (n = c > d);
printf("%d#%d#", m, n);
```

遇到 `&&` 左边是假，右边不会执行。